import os
import queue
import socket
import sys
import threading
from tabulate import tabulate
import re
import argparse

# Main class that handles vulnerability scanning logic
class VulnerablistyScanner:
    def __init__(self):
        """
        Initialize the scanner with predefined service patterns for detecting common services
        based on the banner information retrieved from open ports.
        """
        self.service_patterns = {
            "SSH": ["SSH", "OpenSSH"],
            "HTTP": ["HTTP", "Apache", "nginx"],
            "FTP": ["FTP", "vsftpd", "FileZilla"],
        }
        self.print_lock = threading.Lock()  # Lock to prevent threading conflicts during printing

    # Method to validate an IPv4 address using a regex pattern
    def is_valid_ipv4(self, ip):
        """
        Validates if the given IP address is a valid IPv4 address.
        
        Args:
            ip (str): The IP address to validate.

        Returns:
            bool: True if the IP is valid, False otherwise.
        """
        ip_pattern = r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$'
        return re.match(ip_pattern, ip) is not None

    # Method to validate port numbers are within the valid range (0-65535)
    def is_valid_port(self, port):
        """
        Validates if the given port is a valid port number.

        Args:
            port (int): The port number to validate.

        Returns:
            bool: True if the port is valid, False otherwise.
        """
        try:
            port_num = int(port)
            return 0 <= port_num <= 65535
        except ValueError:
            return False

    # Detects the service running on a port based on the banner information
    def detect_service(self, banner):
        """
        Detects the service type (e.g., SSH, HTTP, FTP) based on the banner information.

        Args:
            banner (str): The banner information retrieved from the port.

        Returns:
            str: The detected service type, or "UNKNOWN" if not matched.
        """
        for service, patterns in self.service_patterns.items():
            for pattern in patterns:
                if pattern in banner:
                    return service
        return "UNKNOWN"

    # Method to print port information in a standardized format
    def print_port_info(self, port, status, banner=None, service=None, version=None):
        """
        Prints detailed information about a scanned port.

        Args:
            port (int): The port number.
            status (str): The status of the port (e.g., open, closed).
            banner (str, optional): The banner information if available.
            service (str, optional): The detected service running on the port.
            version (str, optional): The detected version of the service.
        """
        padding = 60  # For formatting console output
        if status == "open":
            message = f"Port {port} is open! Banner: {banner} Service: {service} Version:{version} "
        else:
            message = f"Port {port} is {status}"
        
        # Ensure that printing happens in a thread-safe manner
        with self.print_lock:
            print(message.ljust(padding), end="\r")

    # Scans a specific port on the target and retrieves service information
    def scan_port(self, target, port):
        """
        Scans a specific port on the target IP and retrieves service information if the port is open.

        Args:
            target (str): The target IP address.
            port (int): The port number to scan.
        """
        open_ports = []
        port_info = []
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(0.5)  # Set timeout for the socket connection attempt
            result = sock.connect_ex((target, port))
            if result == 0:
                # If the port is open, attempt to retrieve banner information
                print(f"Port {port} is open!")
                open_ports.append(port)
                banner = sock.recv(1024).decode("utf-8").strip()
                try:
                    # Detect the service and version based on the banner
                    service = self.detect_service(banner)
                    version = self.get_service_version(service, banner)
                    port_info.append([port, service, version])
                    self.print_port_info(port, "open", banner, service, version)
                except socket.error:
                    pass
                finally:
                    sock.close()  # Close the socket connection
            elif result == 11:
                self.print_port_info(port, "Taking longer to respond")
            else:
                self.print_port_info(port, "is closed :(")
        except KeyboardInterrupt:
            print("Exiting...")
            sys.exit()  # Handle user interrupt (Ctrl+C)
        except socket.gaierror:
            print("Host could not be resolved.")
            sys.exit()
        except socket.error:
            self.print_port_info(port, "couldn't connect")
        finally:
            sock.close()

    # Runs the port scan using multiple threads for faster execution
    def port_scan_threaded(self, target, ports):
        """
        Runs a threaded port scan for the target, scanning the specified ports in parallel.

        Args:
            target (str): The target IP address.
            ports (list): A list of ports to scan.
        """
        open_ports = []
        port_info = []
        threads = []
        max_threads = 50  # Limit the number of threads to prevent system overload

        # Worker function to scan ports in the queue
        def worker():
            while True:
                port = port_queue.get()
                if port is None:
                    break
                self.scan_port(target, port)
                port_queue.task_done()

        # Create a queue for managing ports
        port_queue = queue.Queue()

        # Start threads and assign them to work on ports in the queue
        for _ in range(max_threads):
            t = threading.Thread(target=worker)
            t.start()

        # Add ports to the queue
        for port in ports:
            port_queue.put(port)

        port_queue.join()  # Wait for all threads to finish processing

        # Signal to the threads that no more ports are left to scan
        for _ in range(max_threads):
            port_queue.put(None)

        for t in threads:
            t.join()  # Ensure all threads have completed

        # Display the scan results in a tabulated format
        headers = ["Port", "Service", "Version"]
        print("\n", tabulate(port_info, headers=headers, tablefmt="grid"))

    # Extract SSH version from the banner
    def extract_ssh_version(self, banner):
        """
        Extracts the SSH version from the banner information.

        Args:
            banner (str): The banner information for SSH.

        Returns:
            str: The extracted SSH version, or "Unknown" if not found.
        """
        version_pattern = r"SSH-2.0-(.*?)[ \n]"
        match = re.search(version_pattern, banner)
        if match:
            version = match.group(1)
            return version
        else:
            return "Unknown"

    # Extract HTTP version from the banner
    def extract_http_version(self, banner):
        """
        Extracts the HTTP version from the banner information.

        Args:
            banner (str): The banner information for HTTP.

        Returns:
            str: The extracted HTTP version, or "Unknown" if not found.
        """
        lines = banner.split("\n")
        print(lines)
        match = re.search("Server: (.+?)\s+Last-Modified: (.+)", banner)
        if match:
            version = match.group(1)
            return version
        else:
            return "Unknown"

    # Extract FTP version from the banner
    def extract_ftp_version(self, banner):
        """
        Extracts the FTP version from the banner information.

        Args:
            banner (str): The banner information for FTP.

        Returns:
            str: The extracted FTP version, or "Unknown" if not found.
        """
        parts = banner.split()
        if len(parts) >= 2:
            version = parts
            return version
        else:
            return "Unknown"

    # Main method to retrieve service version based on detected service type
    def get_service_version(self, service, banner):
        """
        Determines and returns the version of the detected service based on the banner.

        Args:
            service (str): The service type (SSH, HTTP, FTP).
            banner (str): The banner information from the service.

        Returns:
            str: The version of the service, or None if no service detected.
        """
        if service == "SSH":
            return self.extract_ssh_version(banner)
        elif service == "HTTP":
            return self.extract_http_version(banner)
        elif service == "FTP":
            return self.extract_ftp_version(banner)
        return

# Main program entry point
if __name__ == "__main__":
    print("Welcome to my Basic Vulnerability Scanner!\n")

    # Setup argparse to handle command-line arguments
    parser = argparse.ArgumentParser(description="Basic Vulnerability Scanner")
    parser.add_argument("target", help="Target IPv4 address")
    parser.add_argument("ports_start", help="Start Port", type=int)
    parser.add_argument("ports_end", help="Stop Port", type=int)

    args = parser.parse_args()

    # Initialize the vulnerability scanner
    scanner = VulnerablistyScanner()

    # Validate IPv4 address and port numbers
    if not scanner.is_valid_ipv4(args.target):
        print("Invalid IPv4 address format!")
        sys.exit()
    if not scanner.is_valid_port(args.ports_start) or not scanner.is_valid_port(args.ports_end):
        print("Invalid port number(s). Port numbers should be between 0 and 65535")
        sys.exit()

    # Perform the port scan
    scanner.port_scan_threaded(args.target, range(args.ports_start, args.ports_end + 1))
